package com.shape.parser;

import com.shape.ast.Source;
import com.shape.ast.SyntaxTree;
import com.shape.ast.nodes.Node;
import com.shape.dictionary.TokenType;
import com.shape.error.LessError;
import com.shape.error.UnexpectedTokenError;
import com.shape.lexer.Token;
import com.shape.lexer.TokenStream;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Parser
 * Converts tokenized code (by lexer) into Abstract Syntax Tree.
 */
public abstract class BaseParser {

    protected TokenStream code;
    protected Source source;
    protected SyntaxTree ast;

    protected ParsingState currentState;
    protected Node currentNode;
    protected Stack<Node> nodeStack;
    protected List<TokenType> expecting;

    protected Token currToken;

    /**
     * Parse some source, generates AST, and add it to the file map.
     *
     * @param filename Source file name
     * @param input Token stream that generated by the Lexer
     * @return Source
     * @throws LessError when parsing error occurs
     */
    public Source parse(String filename, TokenStream input) throws LessError {
        code = input;

        source = new Source(filename);
        ast = source.getAst();
        expecting = new ArrayList<>();
        nodeStack = new Stack<>();

        while (pull() != null) {
            if (expecting.isEmpty()) expect();
            else if (expecting.contains(currToken.getType())) expectationMatched();
            else throw new UnexpectedTokenError(expecting, currToken);
        }

        return source;
    }

    /**
     * Set current parsing state
     * @param status Next parsing State
     */
    protected void setState(ParsingState status) {
        currentState = status;
    }

    /**
     * Expects next token.
     * @param list list of expecting tokens
     */
    protected void expectNext(TokenType... list) {
        expecting.clear();
        for (TokenType token : list) {
            if (!token.getChildren().isEmpty()) expecting.addAll(token.getChildren());
            else expecting.add(token);
        }
    }

    /**
     * Move next and expect token.
     * @param list list of expecting tokens.
     */
    protected Token expectAndPull(TokenType... list) throws UnexpectedTokenError {
        currToken = code.next();
        TokenType searching = currToken.getType();

        boolean found = false;
        for (TokenType token : list) {
            if (!token.getChildren().isEmpty()) {
                for (TokenType child : token.getChildren()) {
                    if (child == searching) {
                        found = true;
                        break;
                    }
                }
                if (found) break;
            }
            else if (token == searching) {
                found = true;
                break;
            }
        }

        if (found) return currToken;
        throw new UnexpectedTokenError(expecting, currToken);
    }

    /**
     * Moves to next.
     * @return token
     */
    protected Token pull() {
        currToken = code.next();
        return currToken;
    }

    protected abstract void expect() throws LessError;
    protected abstract void expectationMatched() throws LessError;
}
